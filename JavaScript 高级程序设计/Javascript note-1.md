###基本概念###

1. 语法
    - 区分大小写
    - 标识符：第一个字母可以是字母、下划线和美元符号（$）;采用驼峰大小写形式。
    - 严格模式："use strict";
    - 语句以分号结尾（可省略）。
2. 变量：松散类型 
3. 数据类型
    - 基本数据类型(undefined、null、Boolean、Number、String)，复杂数据类型(Object).
    - typeof **操作符**：undefined(值未初始化）、boolean、string、number、object(对象或NULL)、function。
    - 0.1+0.2 = 0.30000000000000004问题
    - isFinite():判断数值是否有穷；isNaN():判断是否是数值。 
4. Object类型
    - Constructor：保存着用于创建当前对象的函数。
    - hasOwnProperty(propertyName)：用于检查给定属性是否在当前的对象实例中（而不是在实例的原型中），其中参数名必须以字符串形式指定。
    - isPropertyOf(object)：用于检查传入的对象是否是另一个对象的原型。
    - propertyIsEnumerable(propertyName)：用于检查给定属性是否能够使用for-in语句来枚举，其中参数名必须以字符串形式指定。
    - toString()
    - valueOf()  
5. 操作符
    - 短路操作符：&& ||
    - 加性操作符：如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后拼接。
    - 任何操作数与NaN比较，都是false。
    - 相等操作符(== !=, 强制类型转换)和全等操作符(=== !==)
    - 逗号操作符可以在一条语句中执行多次操作；还可以用于赋值，总是返回表达式中最后一项。
6. 语句
    - ECMAScript不存在块级作用域，因此在循环内部定义的变量可以在外部访问的到。
    - for-in语句用来枚举对象的属性。
    - label语句可以在代码中添加标签，配合break和continue使用。
    - continue语句退出当前循环，继续执行下一次循环。
    - break语句会退出循环，继续执行循环后的语句。
    - switch语句中可以使用任何数据类型，其次case可以是变量或表达式，switch语句在比较时采用的是全等操作符。
7. 函数
    - ECMAScript函数不介意传递进来多少参数以及参数数据类型，命名的参数只提供便利，但不是必需的。
    - 函数体内部可以通过arguments对象来访问参数数组。
    - arguments对象可以与命名参数一起使用。
    - ECMAScript中所有的参数传递的都是值，不可能通过引用传递参数。
    - ECMAScript不存在函数签名特性，函数也不能重载。

###变量、作用域和内存问题###

1. 基本类型和引用类型
    - 基本类型值包括Undefined、Null、Boolean、Number、String，按值访问；引用类型是指Object对象，按引用访问。
    - 复制变量值时，若是基本类型，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上；若是引用类型，同样是将存储在变量对象中的值复制一份放到为新变量分配的空间中，但是这个副本实际是一个指向存储在堆中的一个对象的指针，因此改变其中一个变量就会影响另一个变量。 
    - 参数传递只能是按值传递。
    - 检测基本数据类型：typeof；检测引用数据类型：instanceof
2. 执行环境及作用域
    - 执行环境（execution context）定义了变量和函数有权访问的其他数据。当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。
    - 没有块级作用域，只有函数作用域。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
3. 垃圾收集
    - 标记清除
    - 引用计数，会导致循环引用问题，            

###引用类型###
1.  引用类型是一种数据结构，用于将数据和功能组织在一起。ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统面向对象语言所支持的类和接口等基本结构。
2.  对象时某个特定引用类型的实例。
3.  对象创建：
    - new Object();
    - 对象字面量方法（使用逗号来分隔不同属性，但在最后一个属性值后不要添加逗号[在ie7中会导致错误]）。
    - 点表示法和方括号表示法来访问对象的属性。
4.  Array类型
    - 数组大小是可以动态调整的。
    - length属性：使用length属性可以方便的在数组末尾添加新项。
    - 检测数组：instanceof Array 只能用于单一的全局执行环境；Array.isArray()支持IE9+；
    - 转换方法：
        - toString()方法返回数组中每个值以逗号分隔组成的字符串。
        - valueOf()方法返回数组本身。
        - join()接收一个用作分隔符的字符串，返回包含所有数组项的字符串，默认使用逗号。
    - 栈方法
        - push()接收任意数量的参数，将它们逐个添加到数组末尾，并**返回修改后的数组长度**
        - pop()从数组末尾移除最后一项，减少数组的length值，并返回移除的项。
    - 队列方法
        - shift()移除数组中的第一项，并返回该项，数组长度减一。
        - unshift()在数组前端添加任意个项并返回新数组的长度。 
    - 重排序方法
        - reverse()反转数组项的顺序。
        - sort()默认按升序排列数据项，sort会调用每个数组项的toString方法，然后**比较得到的字符串**，以确定如何排序。
        - sort()方法可以接受一个比较函数，比较函数接收两个参数，如果第一个参数应该位于第二个参数之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。
    - 操作方法
        - concat()创建当前数组的一个副本，然后将接收到的参数添加到这个副本末尾，返回新构建的数组。
        - slice() 基于当前数组的一个或多个项创建新数组。slice()方法可以接受一个或两个参数，即要返回项的起始和结束位置。在只有一个参数情况下，返回从该参数指定位置到数组末尾的所有项；如果有两个参数，返回起始到结束位置之间的项——**但不包括结束位置的项**。如果slice()方法参数有负数，则用数组长度加上该数来确定相应的位置。如果结束位置小于起始位置，则返回空数组。
        - splice()方法
            - 删除：可以删除任意数量的项，只需指定两个参数：要删除的第一项的位置和要删除的项数。
            - 插入：可以向指定位置插入任意数量的项，只需提供三个参数：起始位置，0（要删除的项数）和要插入的项。
            - 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需提供三个参数：起始位置，要删除的项数和要插入的项。
    - 位置方法
        - indexOf()和lastIndexOf()：接收两个参数：要查找的项和表示查找起点的索引，index()从数组开头向后查找，lastIndexOf()则从末尾向前查找。两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1;
        - 仅IE9+浏览器支持。
    - 迭代方法：每个方法接收两个参数：要在每一项上运行的函数和运行函数的作用域对象（可选），传入这些方法中的函数会接受三个参数：数组项的值、该项在数组中的位置和数组对象本身。
        - every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true；
        - some():对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true；
        - filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
        - map():对数组中的每一项运行给定函数，返回每次函数调用结果组成的数组。
        - forEach():对数组中的每一项运行给定函数，无返回值。
        - 仅IE9+浏览器支持。
    - 缩小方法：
        - reduce()和reduceRight()都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后；而reduceRight()则从数组的最后一项开始，向前遍历到第一项。
        - 方法都接受两个参数：一个在每一项上调用的函数和作为缩小基础的初始值（可选）。传递的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。
        - 仅支持IE9+
5. Date对象
    - 使用+操作符将Date对象转换成字符串 +new Date() === Date.now(),返回调用这个方法时的日期和时间的毫秒数。 
6. RegExp类型
    - var expression = /pattern/flags 其中pattern部分是正则表达式,可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一个或多个标志。正则表达式匹配模式支持三个标志：
        - g：表示全局模式，即模式被应用于所有字符串，而非在发现第一个匹配项时立即停止。
        - i：表示不区分大小写模式，即在确定匹配时忽略模式与字符串的大小写。
        - m：表示多行模式
    - 模式中使用的所有元字符必须转义，正则表达式元字符包括：()[]{}\|^$*+.?
    - 正则表达式还可以通过RegExp构造函数来创建.
    - 实例属性
        - global：布尔值，表示是否设置了g标志
        - ignoreCase:布尔值，表示是否设置了i标志
        - multiline：布尔值，表示是否设置了m标志
        - lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起
        - source：正则表达式的字符串表示
    -  实例方法
        -  exec():该方法专门为捕获组设计的。
            -  接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组或者在没有匹配项的情况下返回null。
            -  返回值是一个数组，但包含两个额外的属性：index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。
            -  exec()方法每次只会返回一个匹配项，在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置了全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。
        -  test():接收一个字符串参数，在模式与该参数匹配的情况下返回True，否则返回false
    -  构造函数属性
        -  存储捕获组的构造函数属性：RegExp.$1,RegExp.$2,...,RegExp.$9,分别用于存储第一、第二...第九个匹配的捕获组。
7. Function类型
    - 函数实际是对象，函数名实际是指向函数对象的指针，不会与某个函数绑定。一个函数可以有多个名字。
    - 函数声明与函数表达式：解析器会率先读取函数声明，并使其在执行任何代码前可用；而函数表达式，则必须等到解析器执行到它所在的代码行，才会被解释执行。
    - 作为值得函数：一个函数中返回另一个函数
    - 函数内部属性：
        - arguments 包含着传入函数中的所有参数，该对象具有名为callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数，即callee返回对函数本身的引用。
        - this 引用的是函数据以执行的环境对象。
        - caller 这个属性保存着调用当前函数的函数的引用。
    - 函数属性和方法
        - length：表示函数希望接收的命名参数的个数。
        - prototype：不可枚举
        - apply()和call():在特定的作用域中调用函数，实际上等于设置函数体内this对象的值
            - apply()方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组，其中第二个参数可以是Array的实例，也可以是arguments对象。
            - call()接收参数方式不同，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。
            - apply()和call()真正的用武之地在于能够扩充函数赖以运行的作用域，好处在于对象不需要与方法有任何耦合关系。
        - bind():创建一个函数的实例，其this值会被绑定到传给bind()函数的值。仅支持IE9+。
8. 基本包装类型
    - 3个特殊的引用类型：Boolean、Number和String
    - 引用类型与基本包装类型的主要区别是对象的生存期。创建的引用类型的实例在执行流离开当前作用域之前一直保存在内存中；而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。 
    - Number类型
        - toFixed()按照指定的小数位返回数值的字符串表示。
        - toExponential()返回以指数表示法表示的数值的字符串形式。接收一个参数，参数指定输出结果中的小数位数。
        - toPrecision()接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。
    - String类型
        - length属性：表示字符串中包含多少字符。
        - 字符方法
            - charAt()和charCodeAt():接收一个参数，即基于0的字符位置。charAt()以单字符字符串的形式返回给定位置的那个字符。charCodeAt()返回对应位置字符的字符编码。
            - 使用方括号加数字索引来访问字符串中特定字符,IE7-不支持。
        - 字符串操作方法
            - concat()：用于拼接字符串，返回拼接后的新字符串，对原字符串无影响。
            - 基于子字符串创建新字符串：（对原始字符串无影响）
                - slice()、substr()、substring()三个方法都返回被操作字符串的一个子字符串，而且也都接受一或两个参数。
                - 第一个参数指定子字符串的开始位置，第二个参数(在指定情况下)表示子字符串到哪里结束。
                - slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。substr()的第二个参数指定的则是返回的字符个数。
        - 字符串位置方法
            - indexOf()和lastIndexOf()
        - trim():创建字符串的副本，删除前置和后置的所有空格。对原始字符串无影响。
        - 字符串大小写转换
            - toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()
        - 字符串模式匹配
            - match():接收一个参数——正则表达式，返回匹配数组。
            - search():接收一个正则表达式参数，返回字符串中第一个匹配项的索引，若没有匹配项，则返回-1；
            - replace():接收两个参数，第一个参数可以是正则表达式或字符串，第二个参数可以是一个字符串或函数。若第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有字符串，必须提供一个正则表达式，并指定全局标志。
            - split()基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。接收两个参数，第一个是分隔符字符串，第二个是指定数组大小。    
9. 单体内置对象
    - Global对象
        - isNaN()、isFinite()、parseInt()、parseFloat()都是Global对象的方法
        - URI编码方法：有效的URI不能包括某些字符，例如空格。
            - encodeURI()和encodeURIComponent()方法对URI进行编码。encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号、井字号；而encodeURIComponent()则会对它发现的任何非标准字符（所有非数字字母字符）进行编码。
            - decodeURI()和decodeURIComponent()分别用于解码。
        - eval():代码解析器
    - Math对象
        - 方法
            - min()和max()方法，接收任意多的数值参数。要应用到数组中可以使用Math.max.apply(Math,values);
            - 舍入方法：Math.ceil()和Math.floor()和Math.round()方法
            - random()方法：返回介于0和1之间的一个随机数，不包括0和1；

###面向对象的程序设计###
1. 创建对象
    - 工厂模式：解决了创建多个相似对象的问题，没有解决对象识别的问题。
    - 构造函数模式：使用new操作符来创建特定类型的实例。
        - 构造函数可以当做普通函数来使用。
        - 构造函数的问题在于每个方法都要在每个实例中重新创建一遍。
    - 原型模式
        - 每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
        - 只要创建了一个新函数，就会为该函数创建一个prototype属性，该属性指向函数的原型对象。
        - 默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。
        - 当调用构造函数创建一个新实例后，该实例内部将包含一个指向构造函数的原型对象的指针。必须注意：这个连接存在于实例与构造函数的原型对象之间，而不是实例与构造函数之间。
        - isPrototypeOf()来确定对象之间是否存在某种关系：Person.prototype.isPrototypeOf(person1);
        - Object.getPrototypeOf():返回对象原型
        - 可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，即添加这个属性会阻止我们访问原型中的那个属性，但不会修改那个属性。
        - hasOwnProperty()检测一个属性是存在于实例中，还是存在于原型中。
        - in操作符
            - 单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。
            - for-in循环时，返回的是所有能够通过对象访问的可枚举的属性，既包括实例属性，也包括原型属性。
            - Object.keys()接收对象作为参数，返回一个包含所有可枚举属性的字符串数组，在原型上调用则返回原型属性，在实例中调用则只返回实例属性。
            - Object.getOwnPropertyNames()得到所有实例属性。在原型上调用则返回原型属性，在实例中调用则只返回实例属性。
        - 为减少输入，用一个包含所有属性和方法的对象字面量来重写整个原型对象，导致一个问题：constructor属性不在指定构造函数。
        - 原型模式问题：原型中所有属性是共享的，这种共享对于函数以及包含基本值的属性时可以的，但对于包含引用类型值得属性来说，该值在不同实例中的变动也会是共享的。
    - 组合使用构造函数模式和原型模式
        - 实例属性都在构造函数中定义，而有所以实例共享的属性和方法则在原型中定义。
    - 动态原型模式
        - 通过在构造函数中初始化原型，把所有信息封装在构造函数中。
    - 稳妥构造函数模式
2. ☆ 继承             
    - 原型链 
    - 借用构造函数

###函数表达式###
1. 闭包：
 - 闭包是指有权访问另一个函数作用域中的变量的函数。
 - 闭包只能取得包含函数中任何变量的最后一个值。  
2. 模仿块级作用域（私有作用域）
    
    `(function(){
        
    })();`
3. 私有变量
    - 严格来说，JavaScript中没有私有成员的概念；所有对象属性都是公有的。但有私有变量的概念，任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。
    - 静态私有变量
    - 模块模式
    